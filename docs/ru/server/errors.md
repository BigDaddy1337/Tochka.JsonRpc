# Сервер/Ошибки

Обработка ошибок - это сложно. Здесь описано, что для этого делает библиотека, и чем можете воспользоваться вы. Также посмотрите [Примеры#Ошибки и исключения](examples?id=Ошибки-и-исключения) в примерах.

## Возврат ошибки вручную

Вы можете вручную возвращать объект `IError` из методов в случае ошибок. Для удобства создан сервис `IJsonRpcErrorFactory`,
который поддерживает ошибки из спецификации JSON-RPC (в нем определены ошибки, а также проверки для зарезервированных кодов ошибок)
и прячет детали исключений при соответствующих глобальных настройках.

Наилучшим способом является использовать данный подход **аналогично REST** контроллерам: тип возвращаемого значения метода должен быть `IActionResult`/`IActionResult<T>`/`ObjectResult<T>`.

> `IJsonRpcErrorFactory` проверяет, что данные передаваемые в методы является `Exception` и создает `ExceptionInfo` вместо них, так как исключения не всегда сериализуются в JSON

## Возврат "плохого" HTTP статус кода

В классах контроллера доступны такие методы как `NotFound()`, которые возвращают `IActionResult` с определенным HTTP статус кодом.
Если код будет 4xx или 5xx, то он будет конвертирован в ошибку с помощью `IJsonRpcErrorFactory.HttpError`.

## Исключения

Исключения выброшенные из метода или фильтров оборачиваются в JSON-RPC ответ с ошибкой с помощью `IJsonRpcErrorFactory.Exception`.

Вы можете настраивать логику оборачивания за счет замены реализации `IJsonRpcErrorFactory` в DI или создания своего `IExceptionFilter`, который будет конвертировать исключение в ошибку и складывать в `Result`, аналогично [`JsonRpcExceptionFilter`](https://github.com/tochka-public/Tochka.JsonRpc/blob/master/src/Tochka.JsonRpc.Server/Filters/JsonRpcExceptionFilter.cs).

## Возврат ошибки при сохранении возвращаемого значения

Допустим у вас есть чистая сигнатура метода контроллера, например, `public User GetUser(int id) {}`.
Иногда вам может потребоваться вернуть JSON-RPC ошибку с заданным кодом, сообщением и данными, например, `-10, "user not found", {id: 1}`. Выкидывание обычных исключений не поможет, так как они будут обернуты в `ServerError` (как необработанное исключение).

Используйте `IError.ThrowAsException` или выбрасывайте исключение `JsonRpcErrorException` напрямую:

```cs
errorFactory.MethodNotFound("oops!").ThrowAsException();
errorFactory.Exception(e).ThrowAsException();
errorFactory.Error(-10, "user not found", new { id = 1 }).ThrowAsException();
errorFactory.Error(-10, "users not found", new List<string> { "user1", "user2" }).ThrowAsException();
throw new JsonRpcErrorException(new Error<T>(...));
```

Данный подход не рекомендуется, так как нет причин отказываться от `IActionResult`/`IActionResult<T>`/`ObjectResult<T>` в сигнатурах методов.

## Ранние исключения в пайплайне

Исключения, выброшенные до того, как стало известно, какой метод вызвать, также оборачиваются в JSON-RPC ответ с ошибкой, однако сериализуются по-другому, так как еще не известно, которые настройки сериализации использовать. Смотрите [Сериализация](serialization).

## Исключения выброшенные мидлварями до `JsonRpcMiddleware`

Тут не возможно что-либо сделать, так что ожидайте то поведение, которое настроено в вашем приложении.
