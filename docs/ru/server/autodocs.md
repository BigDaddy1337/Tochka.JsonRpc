# Сервер/Автодокументация

Существует два стандарта автодокументации:

* [Swagger/OpenAPI](https://swagger.io/)
  * создан для REST
  * известный и распространенный
  * имеет множество инструментов, библиотек, генераторов кода и тп.
* [OpenRPC](https://open-rpc.org/)
  * создан специально для JSON-RPC
  * практически никому неизвестен
  * практически не имеет инструментов

Мы поддерживаем оба стандарта за счет двух nuget пакетов. Они выполняют похожие функции: собирают информацию о вашем API в JSON документе и предоставляют к нему доступ на каком-то эндпоинте.

## Swagger/OpenAPI

Поддержка Swagger основана на [Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore) и также включает его UI.

> Пожалуйста, учитывайте что Swagger создавался для REST API и не работает для JSON-RPC без использования грязных уловок. Некоторые функции и сложные сценарии могут не работать.

### Использование

Установите [Tochka.JsonRpc.Swagger](https://www.nuget.org/packages/Tochka.JsonRpc.Swagger/) и добавьте пару строк в `Program.cs`:

```cs
builder.Services.AddControllers();
builder.Services.AddJsonRpcServer();
builder.Services.AddSwaggerWithJsonRpc(Assembly.GetExecutingAssembly()); // <-- добавьте это

var app = builder.Build();

app.UseSwaggerUI(c => c.JsonRpcSwaggerEndpoints(app.Services)); // <-- добавьте это, если вам нужен UI
app.UseJsonRpc();
app.UseRouting();
app.UseEndpoints(static c =>
{
    c.MapControllers();
    c.MapSwagger(); //  <-- добавьте это, альтернатива - UseSwagger()
});
```

> Важное замечание: данные методы расширения делают много предположений, чтобы упростить использование в наиболее распространенных случаях. Если вам нужно настраивать Swagger документы, Swagger UI или избавиться от чтения XML документации, пишите свою реализацию! Вы можете основываться на исходном коде данных методов.

Вам также потребуется [активировать генерацию XML документации](https://docs.microsoft.com/en-us/dotnet/csharp/codedoc) в своем .csproj, и скорее всего вы захотите отключить предупреждение `1591`. Без XML документации приложение будет выкидывать исключения на каждый запрос!

Что вы получите в приложении:

* UI доступный по адресу `/swagger`. Обратите внимание на выпадающий список сверху справа.
* Swagger документ для REST контроллеров может быть также добавлен в конфигурацию для `UseSwaggerUI()`:
```cs
app.UseSwaggerUI(c =>
{
    c.JsonRpcSwaggerEndpoints(app.Services); // JSON-RPC
    c.SwaggerEndpoint("/swagger/rest/swagger.json", "RESTful"); // REST
});
```
* Документ для методов JSON-RPC по адресу `/swagger/jsonrpc/swagger.json`
* Если вы используете несколько реализаций `IJsonSerializerOptionsProvider`, зарегистрированных в DI, то будет доступно больше документов, например, `/swagger/jsonrpc_camelcase/swagger.json` (именование основано на имени типа провайдера, детали смотрите в [`GetDocumentName`](https://github.com/tochka-public/Tochka.JsonRpc/blob/master/src/Tochka.JsonRpc.ApiExplorer/Utils.cs))

### Детали

Здесь описаны все использованные грязные уловки.

#### Исправление адресов URL

Обычно все JSON-RPC запросы идут на один адрес (например `/api/jsonrpc`) и всегда через POST. Для Swagger это все один "метод" с различными параметрами и возвращаемыми значениями.
Мы изменяем внутренние метаданные о методах, чтобы они отображались как разные методы Swagger, за счет добавления имени метода после символа `#`.
Таким образом, Swagger считает их разными адресами, но отправка запроса через Swagger UI продолжает работать. Комбинация адрес + метод должна быть уникальной.
Пример:

<table>
<tr>
    <td>
        JSON-RPC метод
    </td>
    <td>
        Отображение в Swagger
    </td>
</tr>
<tr>
    <td>
        echo.to_lower
    </td>
    <td>
        POST /api/jsonrpc#echo.to_lower
    </td>
</tr>
</table>

#### Исправление запросов и ответов

Второй момент это исправление метаданных параметров и возвращаемых значений, так как нам нужно, чтобы Swagger правильно сгенерировал JSON схемы для каждого запроса и ответа с полями `id`, `jsonrpc`, `method`. Ах да, вы же помните, что поле `params` может быть как объектом, так и массивом? Мы делаем все возможное, чтобы подставить что-нибудь в схему. Реализация содержит генерацию кода в рантайме, поэтому не описана здесь для простоты.

#### Разные настройки сериализации JSON

Последней уловкой является правильная генерация JSON схем в соответствии с вашими правилами сериализации (смотри [Сериализация](serialization)).

Представьте, что в вашем приложении:

* REST обработчик, возвращающий объект типа `ResponseData`, сериализованный в camelCase
* JSON-RPC обработчик, который возвращает тот же самый объект типа `ResponseData`, однако сериализованный в snake_case
* возможно еще один JSON-RPC обработчик, тоже возвращающий этот тип, но уже в PascalCase

Если нам нужно, чтобы все эти обработчики были в одном документе, то нам нужны различные схемы для их ответов, потому что с точки зрения JSON схемы, это разные типы. Но это один и тот же тип в нашем коде!

> Генерация JSON схем основана только на типах C#. Только одна схема генерируется для одного типа.

Если только мы не разделим эти три обработчика в разные Swagger документы, каждый со своей JSON схемой! Именно поэтому мы генерируем разные Swagger документы: один для каждого `IJsonSerializerOptionsProvider`, зарегистрированного в сервисах. Если у вас используется REST, то вам также нужен отдельный документ для него.

---

## OpenRPC

OpenRPC похож на Swagger, но лучше поддерживает специфики JSON-RPC:

* методы различаются по полю `method`, а не по адресу
* есть способ указать, поддерживает ли метод поле `params` в виде массива, объекта или оба варианта

> На текущий момент реализованы только базовые функции: общая информация, сервер, методы и JSON схемы. Не доступны: примеры, внешняя документация, ссылки, ошибки и теги.

### Использование

Установите [Tochka.JsonRpc.OpenRpc](https://www.nuget.org/packages/Tochka.JsonRpc.OpenRpc/) и добавьте пару строк в `Program.cs`:

```cs
builder.Services.AddControllers();
builder.Services.AddJsonRpcServer();
builder.Services.AddOpenRpc(Assembly.GetExecutingAssembly()); // <-- добавьте это

var app = builder.Build();

app.UseJsonRpc();
app.UseRouting();
app.UseEndpoints(static c =>
{
    c.MapControllers();
    c.MapOpenRpc(); //  <-- добавьте это, альтернатива - UseOpenRpc()
});
```

> Важное замечание: данные методы расширения делают много предположений, чтобы упростить использование в наиболее распространенных случаях. Если вам нужно несколько OpenRPC документов или избавиться от чтения XML документации, пишите свою реализацию! Вы можете основываться на исходном коде данных методов.

Вам также потребуется [активировать генерацию XML документации](https://docs.microsoft.com/en-us/dotnet/csharp/codedoc) в своем .csproj, и скорее всего вы захотите отключить предупреждение `1591`. Без XML документации приложение будет выкидывать исключения на каждый запрос!

Что вы получите в приложении:

* OpenRPC документ по адресу `/openrpc/jsonrpc.json` (Вы можете использовать его, чтобы построить UI на [OpenRPC Playground](https://playground.open-rpc.org/))

### Детали

#### Где несколько документов?

По сравнению со Swagger, здесь у нас больший контроль над генерацией JSON схем, поэтому нет необходимости генерировать несколько документов для разных настроек сериализации.

#### Разные URL

Если некоторые из ваших методов работают на других адресах, относительно стандартного, например, за счет `RouteAttribute`, их описание будет включать поле `servers` с данным адресом, который переопределяет значение верхнего поля `servers` по спецификации.

#### Недоступные функции

Нет очевидных способов предоставления информации о примерах, тегах, ошибках или ссылок на документацию из C# кода или XML документации. Данные функции потребовали бы атрибутов или специальных типов "провайдеров примеров" и рефлексии. Это бы сильно усложнило логику и не требуется для изначального релиза.
